#include "ds.h"
#include "stdio.h"
#include<math.h>
#define OFFSET 100
#define LAMBADA 1250000.00 
#define Lsmall 10.0
#define FIFO_SIZE 100
#define STACK_SIZE 100
#define BLACK 0
#define BLUE	  1
#define GREEN 2
#define CYAN	  3
#define RED	  4
#define WHITE  7 
#define Dashed 1
#define SOLID   0

#define MAX_DOUBLE 9999999999999.99

#define Manhattan(x1,y1,x2,y2) ((( (x1)-(x2) ) >= 0? ((x1)-(x2)) : ((x2)-(x1)))  +  (((y1)-(y2) ) >= 0? ((y1)-(y2)) : ((y2)-(y1))))
#define Absdist(x1,x2) ((x1)-(x2))>=0?((x1)-(x2)):((x2)-(x1)) 
extern BOX frame	; 
extern SOURCE source  ;
extern SINK sink	; 
extern WIRELIB wirelib;
extern BUFLIB	buflib ; 
extern VDDLIB	vddlib ; 
extern int SlewLimit; 
extern int CapLimit ;
extern BLOCKAGE blockage;

static int buf_i   ;


typedef struct dme_node{
	double lower;
	double upper; 
	double left;
	double right;
	double weight;
	double capacitance;
	double to_sink_delay;
	double select_x;
	double select_y;
	
	int visited;
	struct dme_node * pleft;
	struct dme_node * pright;
}DME_NODE;


typedef struct buf_node{
	double x;
	double y;
	int buf_id;
//	int buf_lev;
	struct buf_node * next ; 
}BUF_NODE ;

typedef struct dme_tree_node{
	
	struct dme_tree_node * ls;
	struct dme_tree_node * rs;
	double  altitude;
	double  x; 
	double  y; 
	int	   left;
	int	   right; 
	int 	   node_id; 
	int 	   is_sink ; 

}DME_TREE_NODE;

typedef struct tem_node{
	double altitude ; 
	double x; 
	double y;
	int	    prev ; 
	int	    next ; 
	int 	   isit ; 
} BUF_POS;

BUF_POS * FIFO1 ;
BUF_POS * FIFO2 ;

static int Findex1 = 0 ; 
static int Findex2 = 0 ;
BUF_NODE ** bufnode; 



void add_DME_node(DME_NODE *l , DME_TREE_NODE ** Troot, double x, double y){
int i, j ,n ;

	if ( l == NULL) return ;

	if ( Troot == NULL){
		Troot = (DME_TREE_NODE **) malloc ( sizeof (DME_TREE_NODE *)); 
		if ( Troot == NULL) {
			printf(" mallock Error 1 \n");
			exit(1);
		}
	}
		

	if ( (*Troot) == NULL ){
		(*Troot) = (DME_TREE_NODE *) malloc ( sizeof(DME_TREE_NODE)) ; 
		if ( (*Troot) == NULL){
			printf(" mallock Error 2 \n");
			exit(1);
		}
		
		(*Troot) ->altitude = Manhattan(l ->select_x, l ->select_y,x,y)  ;
		(*Troot) -> x = l->select_x ; 
		(*Troot) -> y = l->select_y; 
		(*Troot) ->left = (*Troot)->right =  0;
		(*Troot) ->ls = (*Troot) -> rs = NULL;

	}
	
	add_DME_node(l -> pleft, &((*Troot)->ls),l->select_x,l->select_y) ;
	add_DME_node(l -> pright, &((*Troot)->rs),l->select_x,l->select_y) ;
	
}

void construct_DME_tree(DME_NODE * l, int lnum, DME_TREE_NODE **Troot){
	if ( (*Troot) == NULL ){
		(*Troot) = (DME_TREE_NODE *) malloc ( sizeof(DME_TREE_NODE)) ; 
		if ( (*Troot) == NULL){
			printf(" mallock Error 1 \n");
			exit(1);
		}
	}
	(*Troot) ->altitude = 0; 
	(*Troot) ->left = (*Troot)->right =  0;
	(*Troot) -> x = (*Troot) -> y = 0.0 ; 
	(*Troot) ->ls = (*Troot) -> rs = NULL;
	add_DME_node(l+2*lnum-2,& ((*Troot)->ls), 0.0, 0.0);
	
}


void settle_DME_tree(DME_TREE_NODE * Troot , double  father) { 
	if ( Troot == NULL) 
		return ; 
	
	Troot -> altitude += father; 
	father  = Troot->altitude ;

	if(Troot -> ls != NULL)  
		settle_DME_tree(Troot->ls, Troot->altitude);
	if(Troot -> rs != NULL)
		settle_DME_tree(Troot->rs, Troot->altitude);
}

double max_sink_alt (double * sink_alt_array, int lnum){
int i ; 
double max_value = 0.0; 
	for ( i = 0 ; i < lnum ; i++)
		if ( sink_alt_array[i] > max_value ) {
			max_value = sink_alt_array[i] ; 
		}
		
	return max_value ; 
	

}


void construct_SINK_array( DME_TREE_NODE * Troot , double *sink_alt_array){
static int lnum = 0 ; 	
	if (Troot == NULL) 
		return ; 
	construct_SINK_array(Troot->ls, sink_alt_array); 
	construct_SINK_array(Troot->rs, sink_alt_array); 
	if ( Troot -> ls == NULL) {
		if ( lnum >  sink.num -1 ) {
			printf(" out of range error 1 !\n");
			exit(1); 
		}
		sink_alt_array[lnum] = Troot->altitude ; 
		Troot ->left = lnum ; 
		Troot ->right= lnum; 
		lnum ++ ; 
		
	}
	else if ( Troot -> rs == NULL){
		Troot ->left = Troot ->ls ->left ; 
		Troot ->right = Troot->ls->right ; 
		}
	else {
		Troot ->left = Troot->ls->left ; 
		Troot ->right = Troot ->rs->right ; 

	}

}


void construct_DME_map(DME_TREE_NODE * Troot, DME_TREE_NODE ** Tmap){
static int i = 0 ; 

	if ( Troot == NULL) 
		return ; 
	Troot -> node_id = i ; 
	Troot -> is_sink = 0 ;
	(*(Tmap+i)) = Troot ; 
	i ++ ; 
	construct_DME_map(Troot ->ls, Tmap ); 
	construct_DME_map(Troot ->rs , Tmap); 	
}



void check_DME_tree(DME_TREE_NODE * Troot){
static int i = 0 ; 
	if ( Troot == NULL) 
		return ; 
	if ( Troot->ls == NULL)
		Troot->is_sink = 1 ;
	printf(" %d\t", i++);
	printf(" %f %f \t", Troot->x , Troot->y) ; 
	printf(" %f \t", Troot->altitude);
	printf("\n");
//	printf(" left %d \t", Troot->left);
//	printf(" right %d\n", Troot->right); 
	check_DME_tree(Troot ->ls ); 
	check_DME_tree(Troot ->rs ); 	

}







void check_sink_alt_array(double * sink_alt_array, int lnum){
int i ; 
	for ( i = 0 ;i < lnum ; i++)
		printf(" %f\t ", *(sink_alt_array+i) ); 
	printf("\n");


}


void putFIFO(BUF_POS * b){

	if(Findex2 >= sink.num){
		printf(" out of FIFO range error 1 !\n");
		exit(1);
	}
	
	(FIFO2+Findex2)->altitude = b ->altitude ; 
	(FIFO2+Findex2)->x = b ->x; 
	(FIFO2+Findex2)->y = b ->y; 
	(FIFO2+Findex2)->prev = b ->prev; 	
	(FIFO2+Findex2)->next = b ->next; 
	(FIFO2+Findex2)->isit = b ->isit; 	
	Findex2 ++ ; 
}

int popFIFO(BUF_POS * b){
	Findex1 -- ;
	if (Findex1 < 0 ){
		return 0 ; 
	}
	b->altitude = (FIFO1+Findex1)->altitude ;
	b->x = (FIFO1+Findex1)->x ;
	b->y = (FIFO1+Findex1)->y ;	
	b->next= (FIFO1+Findex1)->next ;
	b->prev= (FIFO1+Findex1)->prev ;
	b->isit= (FIFO1+Findex1)->isit ;
	return 1; 
}

int poreFIFO(){
int i ;
	if (Findex2 <= 0 )
		return 0;
	Findex1 = Findex2 ; 
	Findex2 = 0 ;
	for (i = 0 ;i < Findex1 ; i++){
		(FIFO1+i )->altitude = (FIFO2+i ) ->altitude ; 
		(FIFO1+i )->x = (FIFO2+i ) ->x; 
		(FIFO1+i )->y = (FIFO2+i ) ->y; 
		(FIFO1+i )->prev = (FIFO2+i ) ->prev; 		
		(FIFO1+i )->next = (FIFO2+i ) ->next; 		
		(FIFO1+i )->isit = (FIFO2+i ) ->isit;	

	}
	return 1;

}

void cpy_double (double *saa, double *sbb, int lnum ){
int i ; 
	for ( i = 0 ; i < lnum ; i++)
		sbb[i] = saa[i] ; 

} 

int find_shortest_path(int nd, DME_TREE_NODE * Troot, DME_TREE_NODE **map , double *scc){
int i ; 
int left, right ; 
int mini; 
double minv ; 
	left = (*(map+nd))->left ;
       right = ( *(map+nd)) -> right ; 

	printf(" left is %d\n", left);
	printf(" right is %d\n", right);
	   
	if ( left == -1 && right == -1)
		return  -1; 
	for ( i = left ; i<=right ; i++){
		if ( i == left){
			mini = i ; 
			minv = scc[i] ; 
		}		
		if (scc[i] < minv ){
			mini = i ; 
			minv = scc[i] ; 
		}

	}
	if (minv >= MAX_DOUBLE) return -1;
	return mini; 

}


int find_one_buf_pos(BUF_POS * ibp, int target, DME_TREE_NODE *Troot, DME_TREE_NODE ** map,BUF_POS *ibm, double stepv, double *sbb) {
double remainV = stepv; // remainV < 0 means okay , I find
double distV ; 
int i ;
double x1, y1 ; 
double x2, y2 ;
int left, right; 
BUF_NODE * bf; 

//printf(" remainV is %f\n", remainV);
//printf(" disV is %f\n", distV);

// int find_right_direction(target, left_son's left and right, righ_son's left and right)
	ibm -> altitude = ibp -> altitude + stepv; 
	ibm -> x	=	ibp -> x; 
	ibm -> y	=	ibp -> y;
	ibm -> prev =	ibp -> prev; 
	ibm -> next =	ibp -> next;
	ibm -> isit	=	ibp -> isit;

	printf(" next is %d\n", ibm->next);
	
	while (1){
		distV = (*(map + ibm -> next))->altitude - ibp->altitude ;
		if ( remainV - distV <= 0 ){
			break;
		}
		if ( (*(map+ibm->next))->ls == NULL  ){	
			sbb[ (*(map+ibm->next))->left ] = MAX_DOUBLE ;
			return 0 ;
		}
		
		ibm -> prev = ibm -> next ; 
		if ( (*(map+ibm->next))->ls != NULL )
			if ( target >= (*(map+ibm->next))->ls->left && target <= (*(map+ibm->next))->ls->right){
				ibm->next = (*(map+ibm->next))->ls->node_id;
				continue;
			}
		if ( (*(map+ibm->next))->rs != NULL )
			if ( target >= (*(map+ibm->next))->rs->left && target <= (*(map+ibm->next))->rs->right){
				ibm->next = (*(map+ibm->next))->rs->node_id;			
			}
						
	}
	
	remainV -= ((*(map+ibm->prev))->altitude - ibp->altitude);

	// here I need to add the coordination to the new tree
	x1 =  (*(map+ibm->prev))-> x ; 
	y1 =  (*(map+ibm->prev))-> y ; 
   	x2 =  (*(map+ibm->next))-> x ;
	y2 =  (*(map+ibm->next))-> y ;

	printf(" x1 y1 x2 y2 is %f %f %f %f\n", x1,y1,x2,y2);
	printf(" remainV is %f\n", remainV);
	printf(" adx1x2 is %f\n", Absdist(x1,x2));
	if ( (Absdist(x1,x2)) >= remainV ){
		ibm -> x = (x1>=x2)?(x1-remainV):(x1+remainV);
		ibm -> y = y1 ;	
	}
	else {
		remainV -= Absdist(x1,x2);
		ibm -> x = x2 ; 
		ibm -> y = (y1>=y2)?(y1-remainV):(y1+remainV);
		
	}

	
/*
	if (   ((Absdist(ibm->x, x1 )) + ((Absdist(ibm->y, y1 ))) <= ((LAMBADA) /(Lsmall)))){
		ibm->next = ibm->prev ;
		ibm->x = x1;
		ibm->y = y1; 

	}
	else if (   ((Absdist(ibm->x, x2 )) + ((Absdist(ibm->y, y2 ))) <= ((LAMBADA) /(Lsmall)))){
		ibm->prev = ibm->next ;
		ibm->x = x2;
		ibm->y = y2; 		
	}
*/	
	left = (*(map+ibm->next))->left ; 
	right = (*(map+ibm->next))->right; 
	printf(" the forbidden left is %d\t right is %d\n", left,right);
	for (i = left ; i <= right ; i ++){
		sbb[i] = MAX_DOUBLE;
	
	}
	buf_i ++ ; 
	i = (*(map + ibm ->next))->node_id ;
	bf = (*(bufnode+i)) ;	
	printf("%d\n",i);

	while ( bf->next != NULL )
		bf = bf->next ; 
	bf->next= (BUF_NODE *) malloc(sizeof(BUF_NODE)) ; 	
	bf->next->x = ibm->x; 
	bf->next->y = ibm->y;
	bf->next->buf_id = buf_i ; 
	bf->next->next = NULL ; 
	buf_i ++;
	

	
	return 1;
}



static int StackIndex = 0 ;
int *Stack ; 
void putStack(int nd){
	if ( StackIndex >= STACK_SIZE){
		printf(" Stack out of range error1\n");
		exit(0);
	}
	Stack[StackIndex++] = nd ; 		

}

int 	popStack(){
	if (StackIndex <= 0 ){
		//printf("Stack out of range error2\n");
		return -1; 
	}
	return Stack[--StackIndex] ; 
}

void draw_point( FILE *fp , double x1, double y1, int dash, int colour){
double factor , upleft_x, upleft_y; 	
	if (frame.ur.x != 0)
		factor = (double)9500 / frame.ur.x;

	if (factor > 9500 / frame.ur.y)
		factor = (double)9500 / frame.ur.y;	
	upleft_x = x1*factor + OFFSET;
	upleft_y = y1*factor + OFFSET;
	fprintf(fp,"1 3 %d 1 %d 7 50 -1 -1 0 1 0 %.0f %.0f 40 40 %.0f %.0f %.0f %.0f\n",dash,colour, upleft_x,upleft_y,upleft_x,upleft_y,upleft_x,upleft_y+40);

}

void draw_wire(FILE *fp, double x1, double y1, double x2, double y2, int dash, int colour){
double factor , upleft_x, upleft_y,downright_x,downright_y; 	
double mid_x , mid_y ; 
		if (frame.ur.x != 0)
			factor = (double)9500 / frame.ur.x;
		if (factor > 9500 / frame.ur.y)
			factor = (double)9500 / frame.ur.y; 
		upleft_x = x1*factor + OFFSET;
		upleft_y = y1*factor + OFFSET;
		downright_x = x2 * factor + OFFSET; 
		downright_y = y2 * factor + OFFSET;

		if (upleft_x == downright_x ||upleft_y == downright_y){
			fprintf(fp,"2 1 %d 1 %d 7 50 -1 -1 0 0 0 -1 0 0 2\n", dash,colour);
			fprintf(fp,"\t%.0f %.0f %.0f %.0f\n",upleft_x,upleft_y,downright_x,downright_y);
		}
		else{
			mid_x = downright_x;
			mid_y = upleft_y;
			fprintf(fp,"2 1 %d 1 %d 7 50 -1 -1 0 0 0 -1 0 0 2\n", dash,colour);
			fprintf(fp,"\t%.0f %.0f %.0f %.0f\n",upleft_x,upleft_y,mid_x,mid_y);	
			fprintf(fp,"2 1 %d 1 %d 7 50 -1 -1 0 0 0 -1 0 0 2\n", dash,colour);
			fprintf(fp,"\t%.0f %.0f %.0f %.0f\n",mid_x,mid_y,downright_x,downright_y);				
		}

}







void print_fig_3(DME_TREE_NODE *Troot , DME_TREE_NODE ** map){
	FILE* fp;
	char * filename = "t1.fig";
	fp = (FILE *) fopen(filename,"w");
	double factor;
	double upleft_x;
	double upleft_y;
	double downright_x;
	double downright_y;
	double width;
	double height;
	double t1_x,t1_y,t2_x,t2_y;
	BUF_NODE *bf ; 
	DME_TREE_NODE *t ; 
	Stack = (int *) malloc(sizeof(int)*STACK_SIZE);
	
	
	if (frame.ur.x != 0)
		factor = (double)9500 / frame.ur.x;

	if (factor > 9500 / frame.ur.y)
		factor = (double)9500 / frame.ur.y;
// 	printf("%f\n",factor);
	fprintf(fp,"#FIG 3.1\n");
	fprintf(fp,"Landscape\n");
	fprintf(fp,"Center\n");
	fprintf(fp,"Inches\n");
	fprintf(fp,"1200 2\n");
	int i;
	int nd; 
	
	// draw root 0 
	upleft_x = Troot->x; 
	upleft_y = Troot->y;
	upleft_x = upleft_x*factor + OFFSET;
	upleft_y = upleft_y*factor + OFFSET;
	fprintf(fp,"1 3 0 1 0 7 50 -1 -1 0 1 0 %.0f %.0f 40 40 %.0f %.0f %.0f %.0f\n",upleft_x,upleft_y,upleft_x,upleft_y,upleft_x,upleft_y+40);

	putStack(Troot->node_id) ; 
	while ( (nd = popStack()) != -1){
		t = (*(map+nd))->ls ;
		if ( t != NULL) {
			putStack( t->node_id);
			bf = (*(bufnode+t->node_id))->next ; 
			if (bf != NULL){
				upleft_x = bf->x ;
				upleft_y = bf->y ;
				draw_point(fp,upleft_x,upleft_y, SOLID, GREEN) ;
				draw_wire(fp,(*(map+nd))->x, (*(map+nd))->y,upleft_x,upleft_y, SOLID, BLACK);
			}
			else {
				draw_point(fp,t->x,t->y,SOLID, BLACK) ;				
				draw_wire(fp,(*(map+nd))->x, (*(map+nd))->y,t->x,t->y,SOLID, BLACK);
			}
			while( bf != NULL){
				if ( bf->next != NULL){
					upleft_x = bf->next->x ;
					upleft_y = bf->next->y ;					
					draw_point(fp,upleft_x,upleft_y,SOLID, GREEN) ;
					draw_wire(fp,bf->x, bf->y,upleft_x,upleft_y,SOLID, BLACK);
				}
				else {
					draw_point(fp,t->x,t->y,SOLID,BLACK) ;				
					draw_wire(fp,bf->x, bf->y,t->x,t->y,SOLID, BLACK);
				}
				bf = bf->next ;
			}

		}
		t = (*(map+nd))->rs ;
		if ( t != NULL) {
			putStack( t->node_id);
			bf = (*(bufnode+t->node_id))->next ; 
			if (bf != NULL){
				upleft_x = bf->x ;
				upleft_y = bf->y ;
				draw_point(fp,upleft_x,upleft_y,SOLID, GREEN) ;
				draw_wire(fp,(*(map+nd))->x, (*(map+nd))->y,upleft_x,upleft_y,SOLID, BLACK);
			}
			else {
				draw_point(fp,t->x,t->y,SOLID, BLACK) ;				
				draw_wire(fp,(*(map+nd))->x, (*(map+nd))->y,t->x,t->y,SOLID, BLACK);
			}
			while( bf != NULL){
				if ( bf->next != NULL){
					upleft_x = bf->next->x ;
					upleft_y = bf->next->y ;					
					draw_point(fp,upleft_x,upleft_y,SOLID, GREEN) ;
					draw_wire(fp,bf->x, bf->y,upleft_x,upleft_y,SOLID, BLACK);
				}
				else {
					draw_point(fp,t->x,t->y,SOLID, BLACK) ;				
					draw_wire(fp,bf->x, bf->y,t->x,t->y,SOLID, BLACK);
				}
				bf = bf->next ;
			}

		}


	}


	for ( i = 0 ; i < blockage.num ; i++){
		upleft_x = (double) (blockage.pool[i].ll.x);
		upleft_y = (double) (blockage.pool[i].ll.y);
		downright_x = (double) (blockage.pool[i].ur.x);
		downright_y = (double) (blockage.pool[i].ur.y);
		draw_wire(fp,upleft_x,upleft_y,downright_x,downright_y, Dashed, RED);
		draw_wire(fp,downright_x,downright_y,upleft_x,upleft_y,Dashed, RED);
	}
	

	fclose(fp);
}








void Enhance_Buf(DME_TREE_NODE *Troot,  DME_TREE_NODE ** map){
int i ; 
BUF_NODE * bf; 
	for ( i = 1 ; i < 2 * sink.num ; i++){
		if ( (*(map+i))->is_sink != 1 ){
			bf = (*(bufnode + i))->next ; 
			if (bf == NULL)
				continue;
//			while( bf ->next != NULL)
//				bf = bf ->next ; 
//			bf->next = (BUF_NODE *)malloc(sizeof(BUF_NODE));
//			bf->next->buf_id = bf->buf_id; 
			buf_i ++;
			buf_i ++;
//			bf->next->x = bf->x ; 
//			bf->next->y = bf->y;
//			bf->next->next = NULL ;
		}

	}




}

void Buffer_Placement (DME_TREE_NODE * Troot, int K, double * saa, int lnum){
int ii, flag; 
int j; 
int minNode ; 
double Lmin ; 
double stepv; 
double * sbb = (double *) malloc(sizeof(double) * lnum ); 
BUF_POS bp ; 
BUF_POS bm ; 
DME_TREE_NODE ** DME_tree_map ; 
DME_tree_map = ( DME_TREE_NODE **) malloc (sizeof(DME_TREE_NODE *) * (2 * lnum )); 
FIFO1 = (BUF_POS *) malloc ( sizeof(BUF_POS) * lnum);
FIFO2 = (BUF_POS *) malloc ( sizeof(BUF_POS) * lnum);

	construct_DME_map(Troot, DME_tree_map);

	bp.altitude = 0.0 ; 
	bp.x = 0.0 ;
	bp.y = 0.0 ;
	bp.prev = 0 ; 
	bp.next = 0 ;
	bp.isit = 1 ;
	putFIFO( &bp ) ; 
	poreFIFO();
	for (ii = 0 ; ii < K ; ii++){
	//	while ( poreFIFO() ){
			cpy_double(saa,sbb,lnum); 
			while ( popFIFO(&bp)  ){
				printf(" bp altitude is %f\n", bp.altitude);
				while ( (minNode = find_shortest_path(bp.next,Troot,DME_tree_map,sbb) ) != -1){
					for ( j = 0 ; j < lnum ; j++)
						printf(" sbb %d is %f\n", j, sbb[j]);
					
					//if (sbb[minNode] >= MAX_DOUBLE) break;
					Lmin = saa[minNode] - bp.altitude ; 
				
					stepv = Lmin/(double)(K-ii+1) ;
					printf("stepv is %f\n", stepv);
					//sleep(3);
					// find a buffer insertion point during the shortest path 
					// always shield the explored path 
					flag = find_one_buf_pos(&bp, minNode, Troot, DME_tree_map,&bm, stepv,sbb) ; 

					if (flag == 1 ) {
						putFIFO( &bm ) ; 
						
						printf("******buffer insertion %f %f *************\n", bm.x , bm.y) ; 
						// do some thing for bn (BUF_NODE) 
						
					}
						

				}				

			}
				printf(" findex 2 is %d\n", Findex2);
			if ( !poreFIFO() ){printf("here out\n"); break;}
	//	}



	}

	Enhance_Buf(Troot, DME_tree_map);


	print_fig_3(Troot,DME_tree_map);

	printf("sourcenode 0 0\n");
	printf("num node %d\n", buf_i - sink.num); 
	Out_put_files_coordinate(Troot);
	printf("num sinknode %d\n", sink.num);
	Out_put_files_sink(Troot) ; 
	printf("num wire %d\n", 2*sink.num-1+(buf_i-2*sink.num+1)/2);
	Out_put_files_connect(Troot);	
	printf("num buffer %d\n",(buf_i-2*sink.num+1)/2);
	Out_put_files_buf(2*sink.num, DME_tree_map);
return ;


}














double distance(DME_NODE * n1, DME_NODE * n2){
	double t1 = MAX(n1->lower,n2->lower) - MIN(n1->upper, n2->upper);
	double t2 = MAX(n1->left,n2->left) - MIN(n1->right, n2->right);
/*	printf("%f %f %f %f\n",n1->lower,n1->upper,n1->left,n1->right);
	printf("%f %f %f %f\n",n2->lower,n2->upper,n2->left,n2->right);
	printf("%f %f %f %f\n",(n1->lower+n1->left)/2,(n1->lower-n1->left)/2,(n1->upper+n1->right)/2,(n1->upper-n1->right)/2);
	printf("%f %f %f %f\n",(n2->lower+n2->left)/2,(n2->lower-n2->left)/2,(n2->upper+n2->right)/2,(n2->upper-n2->right)/2);
	
	printf("distance is %f\n", MAX(t1,t2));*/
	return MAX(t1,t2);
}

void merge(DME_NODE * n1, DME_NODE * n2, DME_NODE * parent, double distance){
/*	printf("%f %f %f %f\n",n1->lower,n1->upper,n1->left,n1->right);
	printf("%f %f %f %f\n",n2->lower,n2->upper,n2->left,n2->right);*/
	double b1,b2;
	double alpha = wirelib.lib[0].r;
	double beta = wirelib.lib[0].c;
	if(ELMORE == 1){
		b1 = ((n2->to_sink_delay - n1->to_sink_delay) + alpha*distance*(n2->capacitance + 0.5*beta*distance))/alpha/(n1->capacitance + n2->capacitance + beta*distance);
		b2 = distance - b1;
	}else{
		b1 = (distance - (n1->weight-n2->weight))/2;
		b2 = (distance + (n1->weight-n2->weight))/2;
	}
	printf("%f %f %f %f %f\n",alpha, beta,b1,b2,distance);	
	
	if(b1<0 || b2<0){
		printf("Oh No!\n");
		printf("%f %f %f %f %f\n", b1,b2,distance,n1->weight,n2->weight);
		//return;
	}
/*	Interval ix1,iy1,ix2,iy2;
	ix1->lower = n1->lower - b1;
	ix1->upper = n1->upper + b1;	
	iy1->lower = n1->left - b1;
	iy1->upper = n1->right + b1;
	ix2->lower = n2->lower - b2;
	ix2->upper = n2->upper + b2;
	iy2->lower = n2->left - b2;
	iy2->upper = n2->right + b2;*/
	
	parent->lower = MAX(n1->lower - b1, n2->lower - b2);
	parent->upper = MIN(n1->upper + b1, n2->upper + b2);
	parent->left = MAX(n1->left - b1, n2->left - b2);
	parent->right = MIN(n1->right + b1, n2->right + b2);
	// 	
// 	if((n2->upper + b2) > (n1->upper + b1)){
// 		parent->lower = n2->lower - b2;
// 		parent->upper = n1->upper + b1;
// 	}else{
// 		parent->lower = n1->lower - b1;
// 		parent->upper = n2->upper + b2;
// 	}
// 	
// 	if((n2->right + b2) > (n1->right + b1)){
// 		parent->left = n2->left - b2;
// 		parent->right = n1->right + b1;
// 	}else{
// 		parent->left = n1->left - b1;
// 		parent->right = n2->right + b2;
// 	}
// 	
	parent->pleft = n1;
	parent->pright= n2;
	parent->visited = 0;
	parent->weight = (distance + n1->weight+n2->weight)/2;
	parent->to_sink_delay = alpha*b1*(0.5*beta*b1+n1->capacitance) + n1->to_sink_delay;
	parent->capacitance = n1->capacitance + n2->capacitance + distance*beta;
	n1->visited = 1;
	n2->visited = 1;
	
}

void print_fig_1(DME_NODE * L, int length){
	FILE* fp;
	char * filename = "t1.fig";
	fp = (FILE *) fopen(filename,"w");
	double factor;
	double upleft_x;
	double upleft_y;
	double downright_x;
	double downright_y;
	double width;
	double height;
	double t1_x,t1_y,t2_x,t2_y;
	
	if (frame.ur.x != 0)
		factor = (double)9500 / frame.ur.x;

	if (factor > 9500 / frame.ur.y)
		factor = (double)9500 / frame.ur.y;
// 	printf("%f\n",factor);
	fprintf(fp,"#FIG 3.1\n");
	fprintf(fp,"Landscape\n");
	fprintf(fp,"Center\n");
	fprintf(fp,"Inches\n");
	fprintf(fp,"1200 2\n");
	int i;
	for (i=0; i < (length); i++)
	{
		
		upleft_x = L[i].select_x;
		upleft_y = L[i].select_y;

		upleft_x = upleft_x*factor + OFFSET;
		upleft_y = upleft_y*factor + OFFSET;
		fprintf(fp,"1 3 0 1 0 7 50 -1 -1 0 1 0 %.0f %.0f 40 40 %.0f %.0f %.0f %.0f\n",upleft_x,upleft_y,upleft_x,upleft_y,upleft_x,upleft_y+40);
		
		upleft_x = (L[i].lower+L[i].left)/2;
		upleft_y = (L[i].lower-L[i].left)/2;
		downright_x = (L[i].upper+L[i].right)/2;
		downright_y = (L[i].upper-L[i].right)/2;
		
		upleft_x = upleft_x*factor + OFFSET;
		upleft_y = upleft_y*factor + OFFSET;
		downright_x = downright_x*factor + OFFSET;
		downright_y = downright_y*factor + OFFSET;		
		
		if(i<(length/2+1)){
			fprintf(fp,"1 3 0 1 0 7 50 -1 -1 0 1 0 %.0f %.0f 50 50 %.0f %.0f %.0f %.0f\n",upleft_x,upleft_y,upleft_x,upleft_y,upleft_x,upleft_y+50);
			continue;
		}
		fprintf(fp,"2 1 0 1 0 7 50 -1 -1 0 0 0 -1 0 0 2\n");
		fprintf(fp,"\t%.0f %.0f %.0f %.0f\n",upleft_x,upleft_y,downright_x,downright_y);
		
		t1_x = (L[i].pleft->lower+L[i].pleft->left)/2;
		t1_y = (L[i].pleft->lower-L[i].pleft->left)/2;
		t2_x = (L[i].pleft->upper+L[i].pleft->right)/2;
		t2_y = (L[i].pleft->upper-L[i].pleft->right)/2;
		upleft_x = (t1_x+t2_x)/2;
		upleft_y = (t1_y+t2_y)/2;
		t1_x = (L[i].pright->lower+L[i].pright->left)/2;
		t1_y = (L[i].pright->lower-L[i].pright->left)/2;
		t2_x = (L[i].pright->upper+L[i].pright->right)/2;
		t2_y = (L[i].pright->upper-L[i].pright->right)/2;
		downright_x = (t1_x+t2_x)/2;
		downright_y = (t1_y+t2_y)/2;
		
		upleft_x = upleft_x*factor + OFFSET;
		upleft_y = upleft_y*factor + OFFSET;
		downright_x = downright_x*factor + OFFSET;
		downright_y = downright_y*factor + OFFSET;
		fprintf(fp,"2 1 0 1 0 7 50 -1 -1 0 0 0 -1 0 0 2\n");
		fprintf(fp,"\t%.0f %.0f %.0f %.0f\n",upleft_x,upleft_y,downright_x,downright_y);
		
		
      //		if (i >= general_block_num)
      //			fprintf(fp,"4 0 0 0 0 0 12 0.0000 4 135 180 %.0f %.0f %d\\001\n",(upleft_x+downright_x) / 2 - ID_OFFSET,(upleft_y + downright_y) / 2 + ID_OFFSET,i-general_block_num);
	}
	fclose(fp);
}

void print_fig_2(DME_NODE * L, int length){
	FILE* fp;
	char * filename = "t2.fig";
	fp = (FILE *) fopen(filename,"w");
	double factor;
	double upleft_x;
	double upleft_y;
	double downright_x;
	double downright_y;
	double width;
	double height;
	double t1_x,t1_y,t2_x,t2_y;
	
	if (frame.ur.x != 0)
		factor = (double)9500 / frame.ur.x;

	if (factor > 9500 / frame.ur.y)
		factor = (double)9500 / frame.ur.y;
// 	printf("%f\n",factor);
	fprintf(fp,"#FIG 3.1\n");
	fprintf(fp,"Landscape\n");
	fprintf(fp,"Center\n");
	fprintf(fp,"Inches\n");
	fprintf(fp,"1200 2\n");
	int i;
	for (i=0; i < (length); i++)
	{
		
		upleft_x = L[i].select_x;
		upleft_y = L[i].select_y;

		upleft_x = upleft_x*factor + OFFSET;
		upleft_y = upleft_y*factor + OFFSET;
		fprintf(fp,"1 3 0 1 0 7 50 -1 -1 0 1 0 %.0f %.0f 40 40 %.0f %.0f %.0f %.0f\n",upleft_x,upleft_y,upleft_x,upleft_y,upleft_x,upleft_y+40);
		
		upleft_x = (L[i].lower+L[i].left)/2;
		upleft_y = (L[i].lower-L[i].left)/2;
		downright_x = (L[i].upper+L[i].right)/2;
		downright_y = (L[i].upper-L[i].right)/2;
		
		upleft_x = upleft_x*factor + OFFSET;
		upleft_y = upleft_y*factor + OFFSET;
		downright_x = downright_x*factor + OFFSET;
		downright_y = downright_y*factor + OFFSET;		
		
		if(i<(length/2+1)){
			fprintf(fp,"1 3 0 1 0 7 50 -1 -1 0 1 0 %.0f %.0f 50 50 %.0f %.0f %.0f %.0f\n",upleft_x,upleft_y,upleft_x,upleft_y,upleft_x,upleft_y+50);
			continue;
		}
		fprintf(fp,"2 1 0 1 0 7 50 -1 -1 0 0 0 -1 0 0 2\n");
		fprintf(fp,"\t%.0f %.0f %.0f %.0f\n",upleft_x,upleft_y,downright_x,downright_y);
		
		t1_x = (L[i].pleft->lower+L[i].pleft->left)/2;
		t1_y = (L[i].pleft->lower-L[i].pleft->left)/2;
		t2_x = (L[i].pleft->upper+L[i].pleft->right)/2;
		t2_y = (L[i].pleft->upper-L[i].pleft->right)/2;
		upleft_x = (t1_x+t2_x)/2;
		upleft_y = (t1_y+t2_y)/2;
		t1_x = (L[i].pright->lower+L[i].pright->left)/2;
		t1_y = (L[i].pright->lower-L[i].pright->left)/2;
		t2_x = (L[i].pright->upper+L[i].pright->right)/2;
		t2_y = (L[i].pright->upper-L[i].pright->right)/2;
		downright_x = (t1_x+t2_x)/2;
		downright_y = (t1_y+t2_y)/2;
		
		upleft_x = upleft_x*factor + OFFSET;
		upleft_y = upleft_y*factor + OFFSET;
		downright_x = downright_x*factor + OFFSET;
		downright_y = downright_y*factor + OFFSET;
		fprintf(fp,"2 1 0 1 0 7 50 -1 -1 0 0 0 -1 0 0 2\n");
		fprintf(fp,"\t%.0f %.0f %.0f %.0f\n",upleft_x,upleft_y,downright_x,downright_y);
		
		
      //		if (i >= general_block_num)
      //			fprintf(fp,"4 0 0 0 0 0 12 0.0000 4 135 180 %.0f %.0f %d\\001\n",(upleft_x+downright_x) / 2 - ID_OFFSET,(upleft_y + downright_y) / 2 + ID_OFFSET,i-general_block_num);
	}
	fclose(fp);
}






void trace_back(DME_NODE * n, DME_NODE * parent){
	if(n==NULL)
		return;
	double dis = distance(n,parent);
	
	n->select_x = (MAX(n->lower, parent->select_x - dis) + MIN(n->upper, parent->select_x + dis))/2;
	n->select_y = (MAX(n->left, parent->select_y - dis) + MIN(n->right, parent->select_y + dis))/2;
// 	printf("%f %f %f\n",n->select_x,n->select_y,dis);
	
	trace_back(n->pleft, n);
	trace_back(n->pright, n);
}

void coordianate_translate(DME_NODE * L, int length){
	int i;
	double t1,t2;
	for(i=0;i<length;i++){
		t1 = (L[i].select_x+L[i].select_y)/2;
		t2 = (L[i].select_x-L[i].select_y)/2;
		L[i].select_x = t1;
		L[i].select_y = t2;
	}
}


void dme_core(DME_NODE * L, int length){
	int i,j;
	int count=0;
	DME_NODE * source_node = (DME_NODE *) malloc (sizeof(DME_NODE));
	source_node->lower = 0;
	source_node->upper = 0;
	source_node->left = 0;
	source_node->right = 0;
	source_node->select_x = 0;
	source_node->select_y = 0;
	
	while(count<(length-1)){
		double min_dis=1e20;
		double dis;
		int min_i,min_j;
		for(i=0;i<(count+length);i++){
			if(L[i].visited == 1)
				continue;
			for(j=i+1;j<(count+length);j++){
				if(L[j].visited == 1)
					continue;
				dis = distance(&L[i],&L[j]);
				if(min_dis>dis){
					min_dis = dis;
					min_i = i;
					min_j = j;
				}
			}
			
		}
		merge(&L[min_i],&L[min_j],&L[length+count],min_dis);
		count++;
// 		printf("\n");
	}
	trace_back(&L[2*length-2], &source_node);
	coordianate_translate(L, 2*length-1);
}


void check_DME(DME_NODE * af ) {
static int i = 0 ;
	if ( af == NULL) return ; 
	printf("%d\t", i++);
	printf("(%f, %f)\n", af->select_x, af->select_y);
	check_DME(af -> pleft) ; 
	check_DME(af -> pright) ; 

}


void Out_put_files_coordinate(DME_TREE_NODE * Troot){
BUF_NODE * b ; 
static int i; 
	if (Troot == NULL || Troot->ls == NULL )
		return ; 
	if (Troot->node_id != 0)
		printf("%d %d %d \n", Troot->node_id, (int)Troot->x, (int)Troot->y);
	if (Troot->ls != NULL){
		b = (*(bufnode + Troot->ls->node_id))->next ;
		while( b != NULL){
			printf("%d %d %d\n", b->buf_id, (int)b->x,(int)b->y);
			printf("%d %d %d\n", (b->buf_id)+1, (int)b->x, (int)b->y);
			b = b->next ; 
		}
	}
	if (Troot->rs != NULL){
		b = (*(bufnode + Troot->rs->node_id))->next ;
		while( b != NULL){
			printf("%d %d %d\n", b->buf_id,(int) b->x,(int) b->y);
			printf("%d %d %d\n", (b->buf_id)+1,(int) b->x,(int) b->y);
			b = b->next ; 
		}
	}
	Out_put_files_coordinate(Troot->ls);
	Out_put_files_coordinate(Troot->rs);


}



void Out_put_files_sink(DME_TREE_NODE * Troot){
static int i; 
	if (Troot == NULL )
		return ; 
	
	if (Troot->ls == NULL)
		printf("%d %d %d \n", Troot->node_id, (int) Troot->x, (int) Troot->y);

	Out_put_files_sink(Troot->ls);
	Out_put_files_sink(Troot->rs);


}







void Out_put_files_connect(DME_TREE_NODE * Troot){
BUF_NODE * b ; 
//static int i; 
	if (Troot == NULL)
		return ; 

	if (Troot->ls != NULL){
		b = (*(bufnode + Troot->ls->node_id))->next ;
		if ( b != NULL)
			printf("%d %d %d\n", Troot->node_id, b->buf_id,0);
		else 
			printf("%d %d %d\n", Troot->node_id, Troot->ls->node_id,0);
		
		while( b != NULL){
		//	printf("%d %d %d\n", b->buf_id, b->buf_id,0);
			if ( b->next != NULL)
				printf("%d %d %d\n", b->buf_id+1, b->next->buf_id,0);
			else 
				printf("%d %d %d\n", b->buf_id+1, Troot->ls->node_id,0);
			b = b->next ; 
		}
		
	}
	if (Troot->rs != NULL){
		b = (*(bufnode + Troot->rs->node_id))->next ;
		if ( b != NULL)
			printf("%d %d %d\n", Troot->node_id, b->buf_id,0);
		else 
			printf("%d %d %d\n", Troot->node_id, Troot->rs->node_id,0);

		while( b != NULL){
		//	printf("%d %d %d\n", b->buf_id, b->buf_id,0);
			if ( b->next != NULL)
				printf("%d %d %d\n", b->buf_id+1, b->next->buf_id,0);
			else 
				printf("%d %d %d\n", b->buf_id+1, Troot->rs->node_id,0);
			b = b->next ; 
		}
		
	}

	Out_put_files_connect(Troot->ls);
	Out_put_files_connect(Troot->rs);


}


void Out_put_files_buf(int lnum,  DME_TREE_NODE ** map){
BUF_NODE * b ; 
int i ;
	for ( i = 1; i < lnum ; i++){
		b = (*(bufnode + i))->next ; 
		while ( b != NULL){
			printf("%d %d %d\n", b->buf_id, b->buf_id+1,0);
			if ( (*(map+i))->is_sink != 1 && b->next == NULL )
				printf("%d %d %d\n", b->buf_id, b->buf_id+1,0);
			b = b->next ;
		}

	}		


}

void deferred_merge_embedding(){
	int i;
	int K ;  /*number of levels*/

	DME_NODE * L = (DME_NODE *) malloc (sizeof(DME_NODE) * (2*sink.num));
	DME_TREE_NODE * Tr = NULL ; 

	double *sink_alt_array = (double *) malloc(sizeof(double) * sink.num); 
	double max_path  = 0.0 ; 
	BUF_NODE * bf; 
	buf_i = 2*sink.num -1   ; 
	bufnode = (BUF_NODE **) malloc (sizeof (BUF_NODE *) *(2*sink.num)) ; 

	for ( i = 0 ; i < 2*sink.num  ; i++){
		(*(bufnode+i)) = (BUF_NODE *) malloc (sizeof(BUF_NODE));
		(*(bufnode+i))-> x = (*(bufnode+i))-> y = -1; 
		(*(bufnode+i))->buf_id = -1 ; 
		(*(bufnode+i)) -> next = NULL; 
	}

	
	int length = sink.num;
	for(i=0;i<sink.num; i++){
		//printf("%d %d %d %d\n", sink.pool[i].index,sink.pool[i].x, sink.pool[i].y, sink.pool[i].lc);
		L[i].lower = L[i].upper = (double)(sink.pool[i].x) + (double)(sink.pool[i].y);
		L[i].left = L[i].right = (double)(sink.pool[i].x) - (double)(sink.pool[i].y);
		L[i].visited = 0;
		L[i].weight = 0;
		L[i].to_sink_delay = 0;
		L[i].capacitance = (double)(sink.pool[i].lc);
		L[i].pleft=NULL;
		L[i].pright=NULL;
	}
	
	dme_core(L, length);
	
	//print_fig_1(L,length*2-1);

//	check_DME( L+ 2 * sink.num -2 ) ; 
	

	construct_DME_tree( L, sink.num ,  &Tr) ;
	settle_DME_tree(Tr, 0.0 ); 
	construct_SINK_array( Tr , sink_alt_array); 

	check_DME_tree(Tr) ;
	
	check_sink_alt_array(sink_alt_array,sink.num);

	max_path = max_sink_alt(sink_alt_array,sink.num); 

	K = ceil( max_path / LAMBADA ) ; 
	if ( !(K%2) ) K -= 1 ; 

//	construct_DME_map(Tr, DME_tree_map); 	

	// check the DME_tree_map  right ?
	/*
	for ( i = 0 ; i < 2 * sink.num ; i ++) {
		printf(" %d \t %f \n", i , (DME_tree_map[i])->altitude) ; 

	}
	*/

	Buffer_Placement (Tr, K, sink_alt_array, sink.num) ; 

/*

	for ( i = 0 ; i < 2*sink.num  ; i++){
		bf = (*(bufnode+i))->next ; 
		printf(" node %d  ",i);
		while(bf != NULL){
			printf("buffer (%f,%f) ", bf->x, bf->y);
			bf = bf->next ; 
		}
		printf("\n");

	}

*/


	//TODO
	//print_fig_2(L,length*2-1);

}





